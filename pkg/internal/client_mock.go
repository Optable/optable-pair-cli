// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package internal

import (
	"context"
	v1 "github.com/optable/match-api/v2/gen/optable/external/v1"
	"sync"
)

// Ensure, that CleanroomClientMock does implement CleanroomClient.
// If this is not the case, regenerate this file with moq.
var _ CleanroomClient = &CleanroomClientMock{}

// CleanroomClientMock is a mock implementation of CleanroomClient.
//
//	func TestSomethingThatUsesCleanroomClient(t *testing.T) {
//
//		// make and configure a mocked CleanroomClient
//		mockedCleanroomClient := &CleanroomClientMock{
//			AdvanceAdvertiserStateFunc: func(ctx context.Context) (*v1.Cleanroom, error) {
//				panic("mock out the AdvanceAdvertiserState method")
//			},
//			GetCleanroomFunc: func(ctx context.Context, sensitive bool) (*v1.Cleanroom, error) {
//				panic("mock out the GetCleanroom method")
//			},
//			GetConfigFunc: func(ctx context.Context) (*v1.Cleanroom_Config_PairConfig, error) {
//				panic("mock out the GetConfig method")
//			},
//			GetDownScopedTokenFunc: func(ctx context.Context) (string, error) {
//				panic("mock out the GetDownScopedToken method")
//			},
//			ReadyForMatchFunc: func(ctx context.Context) error {
//				panic("mock out the ReadyForMatch method")
//			},
//			RefreshTokenFunc: func(ctx context.Context) (*v1.Cleanroom, error) {
//				panic("mock out the RefreshToken method")
//			},
//		}
//
//		// use mockedCleanroomClient in code that requires CleanroomClient
//		// and then make assertions.
//
//	}
type CleanroomClientMock struct {
	// AdvanceAdvertiserStateFunc mocks the AdvanceAdvertiserState method.
	AdvanceAdvertiserStateFunc func(ctx context.Context) (*v1.Cleanroom, error)

	// GetCleanroomFunc mocks the GetCleanroom method.
	GetCleanroomFunc func(ctx context.Context, sensitive bool) (*v1.Cleanroom, error)

	// GetConfigFunc mocks the GetConfig method.
	GetConfigFunc func(ctx context.Context) (*v1.Cleanroom_Config_PairConfig, error)

	// GetDownScopedTokenFunc mocks the GetDownScopedToken method.
	GetDownScopedTokenFunc func(ctx context.Context) (string, error)

	// ReadyForMatchFunc mocks the ReadyForMatch method.
	ReadyForMatchFunc func(ctx context.Context) error

	// RefreshTokenFunc mocks the RefreshToken method.
	RefreshTokenFunc func(ctx context.Context) (*v1.Cleanroom, error)

	// calls tracks calls to the methods.
	calls struct {
		// AdvanceAdvertiserState holds details about calls to the AdvanceAdvertiserState method.
		AdvanceAdvertiserState []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetCleanroom holds details about calls to the GetCleanroom method.
		GetCleanroom []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sensitive is the sensitive argument value.
			Sensitive bool
		}
		// GetConfig holds details about calls to the GetConfig method.
		GetConfig []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetDownScopedToken holds details about calls to the GetDownScopedToken method.
		GetDownScopedToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ReadyForMatch holds details about calls to the ReadyForMatch method.
		ReadyForMatch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RefreshToken holds details about calls to the RefreshToken method.
		RefreshToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockAdvanceAdvertiserState sync.RWMutex
	lockGetCleanroom           sync.RWMutex
	lockGetConfig              sync.RWMutex
	lockGetDownScopedToken     sync.RWMutex
	lockReadyForMatch          sync.RWMutex
	lockRefreshToken           sync.RWMutex
}

// AdvanceAdvertiserState calls AdvanceAdvertiserStateFunc.
func (mock *CleanroomClientMock) AdvanceAdvertiserState(ctx context.Context) (*v1.Cleanroom, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockAdvanceAdvertiserState.Lock()
	mock.calls.AdvanceAdvertiserState = append(mock.calls.AdvanceAdvertiserState, callInfo)
	mock.lockAdvanceAdvertiserState.Unlock()
	if mock.AdvanceAdvertiserStateFunc == nil {
		var (
			cleanroomOut *v1.Cleanroom
			errOut       error
		)
		return cleanroomOut, errOut
	}
	return mock.AdvanceAdvertiserStateFunc(ctx)
}

// AdvanceAdvertiserStateCalls gets all the calls that were made to AdvanceAdvertiserState.
// Check the length with:
//
//	len(mockedCleanroomClient.AdvanceAdvertiserStateCalls())
func (mock *CleanroomClientMock) AdvanceAdvertiserStateCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockAdvanceAdvertiserState.RLock()
	calls = mock.calls.AdvanceAdvertiserState
	mock.lockAdvanceAdvertiserState.RUnlock()
	return calls
}

// GetCleanroom calls GetCleanroomFunc.
func (mock *CleanroomClientMock) GetCleanroom(ctx context.Context, sensitive bool) (*v1.Cleanroom, error) {
	callInfo := struct {
		Ctx       context.Context
		Sensitive bool
	}{
		Ctx:       ctx,
		Sensitive: sensitive,
	}
	mock.lockGetCleanroom.Lock()
	mock.calls.GetCleanroom = append(mock.calls.GetCleanroom, callInfo)
	mock.lockGetCleanroom.Unlock()
	if mock.GetCleanroomFunc == nil {
		var (
			cleanroomOut *v1.Cleanroom
			errOut       error
		)
		return cleanroomOut, errOut
	}
	return mock.GetCleanroomFunc(ctx, sensitive)
}

// GetCleanroomCalls gets all the calls that were made to GetCleanroom.
// Check the length with:
//
//	len(mockedCleanroomClient.GetCleanroomCalls())
func (mock *CleanroomClientMock) GetCleanroomCalls() []struct {
	Ctx       context.Context
	Sensitive bool
} {
	var calls []struct {
		Ctx       context.Context
		Sensitive bool
	}
	mock.lockGetCleanroom.RLock()
	calls = mock.calls.GetCleanroom
	mock.lockGetCleanroom.RUnlock()
	return calls
}

// GetConfig calls GetConfigFunc.
func (mock *CleanroomClientMock) GetConfig(ctx context.Context) (*v1.Cleanroom_Config_PairConfig, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetConfig.Lock()
	mock.calls.GetConfig = append(mock.calls.GetConfig, callInfo)
	mock.lockGetConfig.Unlock()
	if mock.GetConfigFunc == nil {
		var (
			cleanroom_Config_PairConfigOut *v1.Cleanroom_Config_PairConfig
			errOut                         error
		)
		return cleanroom_Config_PairConfigOut, errOut
	}
	return mock.GetConfigFunc(ctx)
}

// GetConfigCalls gets all the calls that were made to GetConfig.
// Check the length with:
//
//	len(mockedCleanroomClient.GetConfigCalls())
func (mock *CleanroomClientMock) GetConfigCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetConfig.RLock()
	calls = mock.calls.GetConfig
	mock.lockGetConfig.RUnlock()
	return calls
}

// GetDownScopedToken calls GetDownScopedTokenFunc.
func (mock *CleanroomClientMock) GetDownScopedToken(ctx context.Context) (string, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetDownScopedToken.Lock()
	mock.calls.GetDownScopedToken = append(mock.calls.GetDownScopedToken, callInfo)
	mock.lockGetDownScopedToken.Unlock()
	if mock.GetDownScopedTokenFunc == nil {
		var (
			sOut   string
			errOut error
		)
		return sOut, errOut
	}
	return mock.GetDownScopedTokenFunc(ctx)
}

// GetDownScopedTokenCalls gets all the calls that were made to GetDownScopedToken.
// Check the length with:
//
//	len(mockedCleanroomClient.GetDownScopedTokenCalls())
func (mock *CleanroomClientMock) GetDownScopedTokenCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetDownScopedToken.RLock()
	calls = mock.calls.GetDownScopedToken
	mock.lockGetDownScopedToken.RUnlock()
	return calls
}

// ReadyForMatch calls ReadyForMatchFunc.
func (mock *CleanroomClientMock) ReadyForMatch(ctx context.Context) error {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockReadyForMatch.Lock()
	mock.calls.ReadyForMatch = append(mock.calls.ReadyForMatch, callInfo)
	mock.lockReadyForMatch.Unlock()
	if mock.ReadyForMatchFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.ReadyForMatchFunc(ctx)
}

// ReadyForMatchCalls gets all the calls that were made to ReadyForMatch.
// Check the length with:
//
//	len(mockedCleanroomClient.ReadyForMatchCalls())
func (mock *CleanroomClientMock) ReadyForMatchCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockReadyForMatch.RLock()
	calls = mock.calls.ReadyForMatch
	mock.lockReadyForMatch.RUnlock()
	return calls
}

// RefreshToken calls RefreshTokenFunc.
func (mock *CleanroomClientMock) RefreshToken(ctx context.Context) (*v1.Cleanroom, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRefreshToken.Lock()
	mock.calls.RefreshToken = append(mock.calls.RefreshToken, callInfo)
	mock.lockRefreshToken.Unlock()
	if mock.RefreshTokenFunc == nil {
		var (
			cleanroomOut *v1.Cleanroom
			errOut       error
		)
		return cleanroomOut, errOut
	}
	return mock.RefreshTokenFunc(ctx)
}

// RefreshTokenCalls gets all the calls that were made to RefreshToken.
// Check the length with:
//
//	len(mockedCleanroomClient.RefreshTokenCalls())
func (mock *CleanroomClientMock) RefreshTokenCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRefreshToken.RLock()
	calls = mock.calls.RefreshToken
	mock.lockRefreshToken.RUnlock()
	return calls
}
